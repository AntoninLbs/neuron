// prisma/schema.prisma
// Neuron - App de culture générale avec spaced repetition

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// AUTH (NextAuth.js / Auth.js)
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts Account[]
  sessions Session[]
  projects Project[]
  stats    UserStats?

  @@map("users")
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// USER STATS (gamification globale)
// ============================================

model UserStats {
  id              String   @id @default(cuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // XP & Niveau
  totalXp         Int      @default(0)
  level           Int      @default(1)

  // Streak
  currentStreak   Int      @default(0)
  longestStreak   Int      @default(0)
  lastActivityAt  DateTime?
  streakFreezes   Int      @default(0)  // Nombre de streak freezes disponibles

  // Stats globales
  totalAnswered   Int      @default(0)
  totalCorrect    Int      @default(0)
  totalReviews    Int      @default(0)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("user_stats")
}

// ============================================
// THEMES (catalogue de thématiques)
// ============================================

model Theme {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  icon        String?  // Emoji ou nom d'icône Lucide
  category    String   // "sciences", "histoire", "arts", etc.
  color       String?  // Couleur hex pour l'UI

  // Relations
  projects    ProjectTheme[]
  questions   Question[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("themes")
}

// ============================================
// PROJECTS (projets d'apprentissage)
// ============================================

model Project {
  id             String   @id @default(cuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  name           String
  difficulty     Difficulty @default(INTERMEDIATE)
  dailyGoal      Int        @default(5)  // Nouvelles questions par jour
  isActive       Boolean    @default(true)

  // Stats du projet
  totalCards     Int        @default(0)
  masteredCards  Int        @default(0)

  // Relations
  themes         ProjectTheme[]
  cards          Card[]
  sessions       DailySession[]

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("projects")
}

enum Difficulty {
  BEGINNER
  INTERMEDIATE
  EXPERT
}

// Table de liaison Project <-> Theme (many-to-many)
model ProjectTheme {
  projectId String
  themeId   String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  theme     Theme   @relation(fields: [themeId], references: [id], onDelete: Cascade)

  @@id([projectId, themeId])
  @@map("project_themes")
}

// ============================================
// QUESTIONS (banque de questions)
// ============================================

model Question {
  id           String   @id @default(cuid())
  themeId      String
  theme        Theme    @relation(fields: [themeId], references: [id])

  // Contenu
  question     String
  choices      Json     // ["choix1", "choix2", "choix3", "choix4"]
  correctIndex Int      // 0, 1, 2, ou 3
  explanation  String?
  difficulty   Difficulty @default(INTERMEDIATE)

  // Type de question
  type         QuestionType @default(MCQ)

  // Source (IA ou seed)
  isGenerated  Boolean  @default(false)

  // Relations
  cards        Card[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("questions")
}

enum QuestionType {
  MCQ          // Multiple Choice Question (4 choix)
  TRUE_FALSE   // Vrai/Faux
}

// ============================================
// CARDS (questions assignées à un projet avec scheduling)
// ============================================

model Card {
  id           String   @id @default(cuid())
  projectId    String
  project      Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  questionId   String
  question     Question @relation(fields: [questionId], references: [id])

  // Spaced Repetition
  stageIndex   Int      @default(0)    // Index dans le tableau d'intervalles
  dueDate      DateTime @default(now()) // Prochaine date de révision
  lastResult   Boolean? // null = jamais répondu, true = correct, false = incorrect
  lastAnsweredAt DateTime?

  // Stats de la carte
  timesAnswered Int     @default(0)
  timesCorrect  Int     @default(0)

  // Relations
  reviews      Review[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([projectId, questionId])
  @@map("cards")
}

// ============================================
// REVIEWS (historique des réponses)
// ============================================

model Review {
  id        String   @id @default(cuid())
  cardId    String
  card      Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)

  isCorrect Boolean
  answeredAt DateTime @default(now())

  // Temps de réponse en millisecondes (optionnel)
  responseTime Int?

  @@map("reviews")
}

// ============================================
// DAILY SESSIONS (tracking quotidien)
// ============================================

model DailySession {
  id            String   @id @default(cuid())
  projectId     String
  project       Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  date          DateTime @db.Date // Jour de la session

  // Progression du jour
  reviewsDue    Int      @default(0)   // Révisions à faire
  reviewsDone   Int      @default(0)   // Révisions faites
  newCardsDone  Int      @default(0)   // Nouvelles questions faites
  newCardsGoal  Int      @default(5)   // Objectif nouvelles questions

  // XP gagné ce jour
  xpEarned      Int      @default(0)

  // Complété ?
  isCompleted   Boolean  @default(false)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([projectId, date])
  @@map("daily_sessions")
}

// ============================================
// BADGES (achievements)
// ============================================

model Badge {
  id          String   @id @default(cuid())
  code        String   @unique  // "streak_7", "answers_100", etc.
  name        String
  description String
  icon        String   // Emoji
  xpReward    Int      @default(0)

  // Critères d'obtention (stockés en JSON pour flexibilité)
  criteria    Json     // { "type": "streak", "value": 7 }

  // Relations
  userBadges  UserBadge[]

  createdAt   DateTime @default(now())

  @@map("badges")
}

model UserBadge {
  id        String   @id @default(cuid())
  badgeId   String
  badge     Badge    @relation(fields: [badgeId], references: [id])
  
  // On stocke le userId directement pour pouvoir requêter
  userId    String

  unlockedAt DateTime @default(now())

  @@unique([userId, badgeId])
  @@map("user_badges")
}
